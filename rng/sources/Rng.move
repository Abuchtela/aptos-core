module RngAddress::Rng {
    use std::vector;
    use aptos_framework::timestamp;
    use std::hash;
    use aptos_std::table_with_length::TableWithLength;
    use aptos_std::table_with_length;
    use std::bcs;

    #[test_only]
    use std::signer;

    // TODO:
    // - Add tests for time-based movements between phases
    // - Add tests for failures and different phases
    // - Add token staking and release
    // - Deploy on a network and test
    // - Add a client application to use the random numbers

    /// Address of the owner of the RNG
    const RNG_OWNER: address = @RngAddress;

    /// Error codes
    const ENOT_MODULE_OWNER: u64 = 0;
    const EMODULE_NOT_INITIALIZED: u64 = 1;
    const EINVALID_INIT_PARAMS: u64 = 2;
    const EEMPTY_COMMITMENT: u64 = 3;
    const ECOMMITMENTS_ARE_IDENTICAL: u64 = 4;
    const EALREADY_COMMITTED: u64 = 5;
    const EALREADY_REVEALED_COMMITMENT: u64 = 6;
    const EINVALID_COMMITMENT_REVEAL: u64 = 7;
    const ENO_COMMITMENT_FOUND: u64 = 8;
    const ENOT_IN_COMMITMENT_PHASE: u64 = 9;
    const ENOT_IN_REVEAL_PHASE: u64 = 10;
    const ENOT_IN_BACKUP_REVEAL_PHASE: u64 = 11;
    const EPRIMARY_ENTROPY_NOT_REVEALED: u64 = 12;
    const EINVARIANT_VIOLATION: u64 = 13; // Indicates there must be a bug in the code!

    /// The distinct phases of the RNG contract
    const RNG_PHASE_COMMIT_ENTROPY: u8 = 0; // Users commit entropy
    const RNG_PHASE_REVEAL_ENTROPY: u8 = 1; // Users reveal (already committed) entropy
    const RNG_PHASE_REVEAL_BACKUP_ENTROPY: u8 = 2; // Users reveal (already committed) backup entropy

    /// The RNG that can be used to create random numbers on-chain
    struct RngGenerator has key {
        previous_random_number: RandomNumberWithContext, // The random number generated for the previous round

        round_number: u64, // The round number of the rng (should be sequentially increasing)
        round_phase: u8, // The current phase of the round
        max_user_entropy_count: u64, // The max number of users who can add entropy to the RNG per round
        max_secs_per_phase: u64, // The max number of seconds per each phase of the RNG round
        phase_start_time: u64, // The starting timestamp of the current phase in the round

        committed_entropy_order: vector<address>, // The vector of addresses that committed entropies (in order) for the current round
        committed_entropy_table: TableWithLength<address, CommittedEntropy>, // The table of committed entropies for the current round
        revealed_entropy_table: TableWithLength<address, RevealedEntropy>, // The table of revealed entropies for the current round
        revealed_backup_entropy_table: TableWithLength<address, RevealedEntropy>, // The table of revealed backup entropies for the current round
    }

    /// Entropy committed to by a user (but not yet revealed)
    struct CommittedEntropy has copy, drop, store {
        hashed_entropy: vector<u8>, // The committed entropy, i.e., hashed_entropy = hash(bcs(entropy))
        backup_hashed_entropy: vector<u8>, // The backup committed entropy (in case someone doesn't reveal)
        timestamp: u64, // The time at which the commitment was made (defined by the validator proposing the block)
    }

    /// Entropy revealed by a user (used to calculate the final random number)
    struct RevealedEntropy has copy, drop, store {
        raw_entropy: u64, // The raw entropy revealed after the commitment
    }

    /// A random number that can that also specifies the security properties around generation
    struct RandomNumberWithContext has copy, drop, store {
        random_number: u64, // The random number generated by the RNG
        round_number: u64, // The round number at which the RNG generated this random number
        timestamp: u64, // The timestamp at which this random number was generated
        num_entropy_entries: u64, // The number of entropy entries provided by different accounts
        num_failed_reveals: u64, // The number of entopy entries that failed to reveal after committing
    }

    /// Inits the RNG when first published to the address of the sender
    fun init_module(sender: &signer, max_user_entropy_count: u64, max_secs_per_phase: u64) {
        // Only the owner of the rng can initialize this module
        assert!(signer::address_of(sender) == RNG_OWNER, ENOT_MODULE_OWNER);

        // Verify max_user_entropy_count is valid
        assert!(max_user_entropy_count > 0, EINVALID_INIT_PARAMS);

        // Verify max_secs_per_phase is valid
        assert!(max_secs_per_phase > 0, EINVALID_INIT_PARAMS);

        // Create the new RngGenerator
        let phase_start_time = timestamp::now_seconds();
        let previous_random_number = RandomNumberWithContext {
            random_number: 0,
            round_number: 0,
            timestamp: 0,
            num_entropy_entries: 0,
            num_failed_reveals: 0,
        };
        move_to(
            sender,
            RngGenerator {
                previous_random_number,
                round_number: 0,
                round_phase: RNG_PHASE_COMMIT_ENTROPY,
                max_user_entropy_count,
                max_secs_per_phase,
                phase_start_time,
                committed_entropy_order: vector::empty<address>(),
                committed_entropy_table: table_with_length::new(),
                revealed_entropy_table: table_with_length::new(),
                revealed_backup_entropy_table: table_with_length::new(),
            }
        );
    }

    /// Commits entropy to the current round of the RNG
    fun commit_entropy(sender: &signer, hashed_entropy: vector<u8>, backup_hashed_entropy: vector<u8>) acquires RngGenerator {
        // Ensure the module has been initialized
        assert!(exists<RngGenerator>(RNG_OWNER), EMODULE_NOT_INITIALIZED);
        let rng_generator = borrow_global_mut<RngGenerator>(RNG_OWNER);

        // Ensure we're in the correct phase for commitments
        assert!(rng_generator.round_phase == RNG_PHASE_COMMIT_ENTROPY, ENOT_IN_COMMITMENT_PHASE);

        // If enough time has elapsed, move to the reveal phase
        let current_time = timestamp::now_seconds();
        if (current_phase_timed_out(rng_generator, current_time)) {
            move_to_reveal_phase(rng_generator, current_time);
            assert!(false, ENOT_IN_COMMITMENT_PHASE)
        };

        // Ensure the sender hasn't already sent a commitment
        let committer = signer::address_of(sender);
        assert!(!table_with_length::contains(&rng_generator.committed_entropy_table, committer), EALREADY_COMMITTED);

        // Verify the hashed entropies are not empty
        assert!(hashed_entropy != vector::empty<u8>(), EEMPTY_COMMITMENT);
        assert!(backup_hashed_entropy != vector::empty<u8>(), EEMPTY_COMMITMENT);

        // Verify the hashed entropies are not equal
        assert!(hashed_entropy != backup_hashed_entropy, ECOMMITMENTS_ARE_IDENTICAL);

        // Create and store a new entropy commitment for the sender
        let timestamp = timestamp::now_seconds();
        let committed_entropy = CommittedEntropy {
            hashed_entropy,
            backup_hashed_entropy,
            timestamp,
        };
        table_with_length::add(&mut rng_generator.committed_entropy_table, committer, committed_entropy);
        vector::push_back(&mut rng_generator.committed_entropy_order, committer);

        // If we've hit the max number of users, move to the next phase
        if (vector::length(& rng_generator.committed_entropy_order) >= rng_generator.max_user_entropy_count) {
            move_to_reveal_phase(rng_generator, current_time);
        }
    }

    /// Reveals the entropy of the commitment made by the given account
    fun reveal_entropy(sender: &signer, raw_entropy: u64) acquires RngGenerator {
        // Ensure the module has been initialized
        assert!(exists<RngGenerator>(RNG_OWNER), EMODULE_NOT_INITIALIZED);
        let rng_generator = borrow_global_mut<RngGenerator>(RNG_OWNER);

        // Ensure we're in the correct phase for reveals
        assert!(rng_generator.round_phase == RNG_PHASE_REVEAL_ENTROPY, ENOT_IN_REVEAL_PHASE);

        // If enough time has elapsed, move to the backup reveal phase
        let current_time = timestamp::now_seconds();
        if (current_phase_timed_out(rng_generator, current_time)) {
            move_to_backup_reveal_phase(rng_generator, current_time);
            assert!(false, ENOT_IN_REVEAL_PHASE)
        };

        // Verify the raw entropy hasn't already been revealed
        let committer = signer::address_of(sender);
        assert!(!table_with_length::contains(&rng_generator.revealed_entropy_table, committer), EALREADY_REVEALED_COMMITMENT);

        // Find the commitment of the sender, verify the commitment, and update the raw entropies
        if (table_with_length::contains(&rng_generator.committed_entropy_table, committer)) {
            // Verify the hash matches the raw entropy
            let hashed_entropy = table_with_length::borrow(&rng_generator.committed_entropy_table, committer).hashed_entropy;
            verify_commitment(hashed_entropy, raw_entropy);

            // Insert the raw entropy into the revealed entropies table
            let revealed_entropy = RevealedEntropy {
                raw_entropy,
            };
            table_with_length::add(&mut rng_generator.revealed_entropy_table, committer, revealed_entropy);
        } else {
            assert!(false, ENO_COMMITMENT_FOUND);
        };

        // If all entropies have been revealed, we can generate the new random number and move to the next round
        let committed_order_length = vector::length(&rng_generator.committed_entropy_order);
        let committed_table_length = table_with_length::length(&rng_generator.committed_entropy_table);
        let revealed_table_length = table_with_length::length(&rng_generator.revealed_entropy_table);
        if (committed_order_length == committed_table_length && committed_table_length == revealed_table_length) {
            generate_random_number_using_all_commitments(rng_generator);
        }
    }

    /// Generates the new random number using all committed and revealed entropies.
    /// Stores the new random number in the generator and updates the RNG to the next round.
    ///
    /// Note: this function assumes the committed order, committed table and revealed table all have the
    /// same length and that all committers have revealed!
    fun generate_random_number_using_all_commitments(rng_generator: &mut RngGenerator) {
        let num_entropies = table_with_length::length(&mut rng_generator.revealed_entropy_table);
        let entropy_counter = 0;

        let random_number = rng_generator.previous_random_number.random_number;
        while (entropy_counter < num_entropies) {
            // Get the commitment timestamp and XOR it with the random number
            let committer = vector::borrow(&rng_generator.committed_entropy_order, entropy_counter);
            let commitment_timestamp = table_with_length::borrow(&rng_generator.committed_entropy_table, *committer).timestamp;
            random_number = random_number ^ commitment_timestamp;

            // Get the raw entropy and XOR it with the random number
            let raw_entropy = table_with_length::borrow(&rng_generator.revealed_entropy_table, *committer).raw_entropy;
            random_number = random_number ^ raw_entropy;

            // Increment the entropy counter
            entropy_counter = entropy_counter + 1;
        };

        // Store the newly generated random number
        update_and_store_random_number(rng_generator, random_number, num_entropies, 0);

        // Clear the state of the RNG (i.e., commitments and reveals)
        clear_internal_state(rng_generator);

        // Verify all data has been cleared
        verify_internal_state_is_clean(rng_generator);
    }

    /// Reveals the backup entropy of the commitment made by the given account.
    ///
    /// Note that whichever accounts did not reveal successfully in the reveal phase
    /// cannot reveal backup entropy.
    fun reveal_backup_entropy(sender: &signer, raw_entropy: u64) acquires RngGenerator {
        // Ensure the module has been initialized
        assert!(exists<RngGenerator>(RNG_OWNER), EMODULE_NOT_INITIALIZED);
        let rng_generator = borrow_global_mut<RngGenerator>(RNG_OWNER);

        // Ensure we're in the correct phase for reveals
        assert!(rng_generator.round_phase == RNG_PHASE_REVEAL_BACKUP_ENTROPY, ENOT_IN_BACKUP_REVEAL_PHASE);

        // If enough time has elapsed, generate a random number using the
        // entropy that is available and move to the next round.
        let current_time = timestamp::now_seconds();
        if (current_phase_timed_out(rng_generator, current_time)) {
            // TODO: implement me!
            assert!(false, ENOT_IN_BACKUP_REVEAL_PHASE)
        };

        // Verify the sender is allowed to reveal backup entropy, i.e., it has already
        // revealed the primary entropy.
        let committer = signer::address_of(sender);
        assert!(table_with_length::contains(&rng_generator.revealed_entropy_table, committer), EPRIMARY_ENTROPY_NOT_REVEALED);

        // Verify the raw backup entropy hasn't already been revealed
        assert!(!table_with_length::contains(&rng_generator.revealed_backup_entropy_table, committer), EALREADY_REVEALED_COMMITMENT);

        // Find the backup commitment of the sender, verify the commitment, and update the backup entropies
        if (table_with_length::contains(&rng_generator.committed_entropy_table, committer)) {
            // Verify the hash matches the raw backup entropy
            let hashed_entropy = table_with_length::borrow(&rng_generator.committed_entropy_table, committer).backup_hashed_entropy;
            verify_commitment(hashed_entropy, raw_entropy);

            // Insert the raw entropy into the revealed backup entropies table
            let revealed_entropy = RevealedEntropy {
                raw_entropy,
            };
            table_with_length::add(&mut rng_generator.revealed_backup_entropy_table, committer, revealed_entropy);
        } else {
            assert!(false, ENO_COMMITMENT_FOUND);
        };

        // If all backup entropies have been revealed, we can generate the new random number and move to the next round
        let committed_order_length = vector::length(&rng_generator.committed_entropy_order);
        let committed_table_length = table_with_length::length(&rng_generator.committed_entropy_table);
        let revealed_table_length = table_with_length::length(&rng_generator.revealed_entropy_table);
        let revealed_backup_table_length = table_with_length::length(&rng_generator.revealed_backup_entropy_table);
        if (revealed_table_length == revealed_backup_table_length) {
            assert!(committed_table_length > revealed_table_length, EINVARIANT_VIOLATION);
            assert!(committed_order_length == revealed_table_length, EINVARIANT_VIOLATION);
            generate_random_number_using_partial_reveals_and_backups(rng_generator);
        }
    }

    /// Generates the new random number using all partially revealed entropies (and backups).
    /// Stores the new random number in the generator and updates the RNG to the next round.
    ///
    /// Note: this function assumes the revealed table and revealed backup table have the
    /// same length!
    fun generate_random_number_using_partial_reveals_and_backups(rng_generator: &mut RngGenerator) {
        let num_committers = vector::length(& rng_generator.committed_entropy_order);
        let committer_counter = 0;

        let random_number = rng_generator.previous_random_number.random_number;
        while (committer_counter < num_committers) {
            // Get the commitment timestamp and XOR it with the random number
            let committer = vector::borrow(&rng_generator.committed_entropy_order, committer_counter);
            if (table_with_length::contains(&rng_generator.revealed_entropy_table, *committer)
                && table_with_length::contains(&rng_generator.revealed_backup_entropy_table, *committer) ) {
                // Get the commitment timestamp and XOR it with the random number
                let commitment_timestamp = table_with_length::borrow(&rng_generator.committed_entropy_table, *committer).timestamp;
                random_number = random_number ^ commitment_timestamp;

                // Get the raw entropy and XOR it with the random number
                let raw_entropy = table_with_length::borrow(&rng_generator.revealed_entropy_table, *committer).raw_entropy;
                random_number = random_number ^ raw_entropy;

                // Get the raw backup entropy and XOR it with the random number
                let raw_entropy = table_with_length::borrow(&rng_generator.revealed_backup_entropy_table, *committer).raw_entropy;
                random_number = random_number ^ raw_entropy;

                // Increment the committer counter
                committer_counter = committer_counter + 1;
            };
        };

        // Store the newly generated random number
        let num_entropies = table_with_length::length(&rng_generator.revealed_entropy_table);
        let num_failed_reveals = num_committers - num_entropies;
        update_and_store_random_number(rng_generator, random_number, num_entropies, num_failed_reveals);

        // Clear the state of the RNG (i.e., commitments and reveals)
        clear_internal_state(rng_generator);

        // Verify all data has been cleared
        verify_internal_state_is_clean(rng_generator);
    }

    /// Updates the given rng_generator to move to the reveal phase
    fun move_to_reveal_phase(rng_generator: &mut RngGenerator, current_time: u64) {
        rng_generator.round_phase = RNG_PHASE_REVEAL_ENTROPY;
        rng_generator.phase_start_time = current_time;
    }

    /// Updates the given rng_generator to move to the backup reveal phase
    fun move_to_backup_reveal_phase(rng_generator: &mut RngGenerator, current_time: u64) {
        rng_generator.round_phase = RNG_PHASE_REVEAL_BACKUP_ENTROPY;
        rng_generator.phase_start_time = current_time;
    }

    /// Returns true iff the current phase of the RNG has timedout
    fun current_phase_timed_out(rng_generator: &RngGenerator, current_time: u64): bool {
        (current_time - rng_generator.phase_start_time) > rng_generator.max_secs_per_phase
    }

    /// Fails if the given commitment and pre-image do not match
    fun verify_commitment(hashed_entropy: vector<u8>, raw_entropy: u64) {
        let raw_entropy_encoded = bcs::to_bytes(&raw_entropy);
        assert!(hash::sha3_256(raw_entropy_encoded) == hashed_entropy, EINVALID_COMMITMENT_REVEAL);
    }

    /// Updates and stores the given random number for the specified generator
    fun update_and_store_random_number(rng_generator: &mut RngGenerator, random_number: u64, num_entropy_entries: u64, num_failed_reveals: u64) {
        // Add context to the random number
        let timestamp = timestamp::now_seconds();
        let random_number_with_context = RandomNumberWithContext {
            random_number,
            round_number: rng_generator.round_number,
            timestamp,
            num_entropy_entries,
            num_failed_reveals,
        };

        // Update the state of the RNG with the new random number and move to the next round
        rng_generator.previous_random_number = random_number_with_context;
        rng_generator.round_number = rng_generator.round_number + 1;
        rng_generator.round_phase = RNG_PHASE_COMMIT_ENTROPY;
        rng_generator.phase_start_time = timestamp;
    }

    /// Clears the internal state of the rng_generator
    fun clear_internal_state(rng_generator: &mut RngGenerator) {
        let entropy_counter = 0;
        let num_entropies = table_with_length::length(&mut rng_generator.revealed_entropy_table);

        while (entropy_counter < num_entropies) {
            // Clear the committer data from all structures
            let committer = vector::remove(&mut rng_generator.committed_entropy_order, 0); // TODO: Optimize!
            if (table_with_length::contains(&mut rng_generator.committed_entropy_table, committer)) {
                let _ = table_with_length::remove(&mut rng_generator.committed_entropy_table, committer);
            };
            if (table_with_length::contains(&mut rng_generator.revealed_entropy_table, committer)) {
                let _ = table_with_length::remove(&mut rng_generator.revealed_entropy_table, committer);
            };
            if (table_with_length::contains(&mut rng_generator.revealed_backup_entropy_table, committer)) {
                let _ = table_with_length::remove(&mut rng_generator.revealed_backup_entropy_table, committer);
            };

            // Increment the entropy counter
            entropy_counter = entropy_counter + 1;
        };
    }

    /// Verifies that the internal state of the rng_generator is clean, i.e.,
    /// that all tables and vectors are empty.
    fun verify_internal_state_is_clean(rng_generator: &mut RngGenerator) {
        assert!(vector::length(&rng_generator.committed_entropy_order) == 0, EINVARIANT_VIOLATION);
        assert!(table_with_length::length(&rng_generator.committed_entropy_table) == 0, EINVARIANT_VIOLATION);
        assert!(table_with_length::length(&rng_generator.revealed_entropy_table) == 0, EINVARIANT_VIOLATION);
        assert!(table_with_length::length(&rng_generator.revealed_backup_entropy_table) == 0, EINVARIANT_VIOLATION);
    }

    /// Returns the last generated random number. This is what clients (e.g., other
    /// modules are expected to call).
    fun get_random_number(_sender: &signer): RandomNumberWithContext acquires RngGenerator {
        // Ensure the module has been initialized
        assert!(exists<RngGenerator>(RNG_OWNER), EMODULE_NOT_INITIALIZED);

        // Get the random number
        let rng_generator = borrow_global<RngGenerator>(RNG_OWNER);
        rng_generator.previous_random_number
    }

    #[test(account = @0xC0FFEE, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = ENOT_MODULE_OWNER, location = Self)]
    fun test_init_not_owner(aptos_framework: &signer, account: signer) {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_secs = 123456;
        timestamp::update_global_time_for_test_secs(global_time_secs);

        // Initialize the module
        init_module(&account, 1, 10000);
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EINVALID_INIT_PARAMS, location = Self)]
    fun test_init_invalid_user_count(aptos_framework: &signer, account: signer) {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_secs = 123456;
        timestamp::update_global_time_for_test_secs(global_time_secs);

        // Initialize the module
        init_module(&account, 0, 10000);
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EINVALID_INIT_PARAMS, location = Self)]
    fun test_init_invalid_timeout(aptos_framework: &signer, account: signer) {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_secs = 123456;
        timestamp::update_global_time_for_test_secs(global_time_secs);

        // Initialize the module
        init_module(&account, 100, 0);
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EMODULE_NOT_INITIALIZED, location = Self)]
    fun test_not_init_commit(aptos_framework: &signer, account: signer) acquires RngGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_secs = 123456;
        timestamp::update_global_time_for_test_secs(global_time_secs);

        // Attempt to commit entropy
        let raw_entropy = 1010101;
        let hashed_entropy = hash::sha3_256(bcs::to_bytes(&raw_entropy));
        commit_entropy(&account, hashed_entropy, hashed_entropy);
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EMODULE_NOT_INITIALIZED, location = Self)]
    fun test_not_init_reveal(aptos_framework: &signer, account: signer) acquires RngGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_secs = 123456;
        timestamp::update_global_time_for_test_secs(global_time_secs);

        // Attempt to reveal entropy
        reveal_entropy(&account, 754);
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EMODULE_NOT_INITIALIZED, location = Self)]
    fun test_not_init_reveal_backup(aptos_framework: &signer, account: signer) acquires RngGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_secs = 123456;
        timestamp::update_global_time_for_test_secs(global_time_secs);

        // Attempt to reveal backup entropy
        reveal_backup_entropy(&account, 754);
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EEMPTY_COMMITMENT, location = Self)]
    fun test_empty_commitment(aptos_framework: &signer, account: signer) acquires RngGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_secs = 123456;
        timestamp::update_global_time_for_test_secs(global_time_secs);

        // Initialize the module
        init_module(&account, 1, 10000);

        // Attempt to commit empty entropy
        commit_entropy(&account, vector::empty<u8>(), vector::empty<u8>());
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EEMPTY_COMMITMENT, location = Self)]
    fun test_empty_backup_commitment(aptos_framework: &signer, account: signer) acquires RngGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_secs = 123456;
        timestamp::update_global_time_for_test_secs(global_time_secs);

        // Initialize the module
        init_module(&account, 1, 10000);

        // Attempt to commit empty backup entropy
        let raw_entropy = 19994;
        let hashed_entropy = hash::sha3_256(bcs::to_bytes(&raw_entropy));
        commit_entropy(&account, hashed_entropy, vector::empty<u8>());
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = ECOMMITMENTS_ARE_IDENTICAL, location = Self)]
    fun test_identical_commitments(aptos_framework: &signer, account: signer) acquires RngGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_secs = 123456;
        timestamp::update_global_time_for_test_secs(global_time_secs);

        // Initialize the module
        init_module(&account, 1, 10000);

        // Attempt to commit identical entropy pairs
        let raw_entropy = 123;
        let hashed_entropy = hash::sha3_256(bcs::to_bytes(&raw_entropy));
        commit_entropy(&account, hashed_entropy, hashed_entropy);
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = EINVALID_COMMITMENT_REVEAL, location = Self)]
    fun test_invalid_reveal(aptos_framework: &signer, account: signer) acquires RngGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_secs = 123456;
        timestamp::update_global_time_for_test_secs(global_time_secs);

        // Initialize the module
        init_module(&account, 1, 10000);

        // Commit some entropy
        let raw_entropy = 10101;
        let hashed_entropy = hash::sha3_256(bcs::to_bytes(&raw_entropy));
        let raw_backup_entropy = 10102;
        let hashed_backup_entropy = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy));
        commit_entropy(&account, hashed_entropy, hashed_backup_entropy);

        // Reveal incorrect entropy
        timestamp::update_global_time_for_test_secs(global_time_secs + 500);
        reveal_entropy(&account, raw_entropy + 1);
    }

    #[test(account = @RngAddress, aptos_framework = @aptos_framework)]
    fun test_rng_happy_paths(aptos_framework: &signer, account: signer) acquires RngGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_secs = 123456;
        timestamp::update_global_time_for_test_secs(global_time_secs);

        // Initialize the module
        init_module(&account, 1, 100000);

        // Read and verify the generated random number
        let previous_random_number = get_random_number(&account);
        assert!(previous_random_number.random_number == 0, 0);
        assert!(previous_random_number.round_number == 0, 0);
        assert!(previous_random_number.timestamp == 0, 0);
        assert!(previous_random_number.num_entropy_entries == 0, 0);
        assert!(previous_random_number.num_failed_reveals == 0, 0);

        // Generate and test several random number generations
        let generation_counter = 0;
        while (generation_counter < 10) {
            // Update the global timestamp
            let global_time_secs = global_time_secs + ((generation_counter + 1) * 1000);
            timestamp::update_global_time_for_test_secs(global_time_secs);

            // Commit some entropy
            let raw_entropy = 2345;
            let hashed_entropy = hash::sha3_256(bcs::to_bytes(&raw_entropy));
            let raw_backup_entropy = 12121;
            let hashed_backup_entropy = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy));
            commit_entropy(&account, hashed_entropy, hashed_backup_entropy);

            // Reveal the entropy
            let new_global_timestamp = global_time_secs + 500;
            timestamp::update_global_time_for_test_secs(new_global_timestamp);
            reveal_entropy(&account, raw_entropy);

            // Read the newly generated random number
            let random_number_with_context = get_random_number(&account);
            assert!(random_number_with_context.round_number == generation_counter, 0);
            assert!(random_number_with_context.timestamp == new_global_timestamp, 0);
            assert!(random_number_with_context.num_entropy_entries == 1, 0);
            assert!(random_number_with_context.num_failed_reveals == 0, 0);

            // Increment the generation counter
            generation_counter = generation_counter + 1;
        };
    }

    #[test(rng_account = @RngAddress, user_account_1 = @0xC0FFEE, user_account_2 = @0xABCDE, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = ENOT_IN_COMMITMENT_PHASE, location = Self)]
    fun test_rng_commit_phase_timeout(aptos_framework: &signer, rng_account: signer, user_account_1: signer, user_account_2: signer) acquires RngGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_secs = 100000;
        timestamp::update_global_time_for_test_secs(global_time_secs);

        // Initialize the module
        let max_user_entropy_count = 2;
        let max_secs_per_phase = 100;
        init_module(&rng_account, max_user_entropy_count, max_secs_per_phase);

        // Commit some entropy for user 1
        let raw_entropy = 1111;
        let hashed_entropy = hash::sha3_256(bcs::to_bytes(&raw_entropy));
        let raw_backup_entropy = 12121;
        let hashed_backup_entropy = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy));
        commit_entropy(&user_account_1, hashed_entropy, hashed_backup_entropy);

        // Elapse enough time so that we now move to the reveal phase
        global_time_secs = global_time_secs + max_secs_per_phase + 1;
        timestamp::update_global_time_for_test_secs(global_time_secs);

        // Committing some entropy for user 2 should fail
        let raw_entropy = 99999;
        let hashed_entropy = hash::sha3_256(bcs::to_bytes(&raw_entropy));
        commit_entropy(&user_account_2, hashed_entropy, hashed_entropy);
    }

    #[test(rng_account = @RngAddress, user_account_1 = @0xC0FFEE, user_account_2 = @0xABCDE, aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = ENOT_IN_REVEAL_PHASE, location = Self)]
    fun test_rng_reveal_phase_timeout(aptos_framework: &signer, rng_account: signer, user_account_1: signer, user_account_2: signer) acquires RngGenerator {
        // Initialize the on-chain timestamps in the aptos framework
        timestamp::set_time_has_started_for_testing(aptos_framework);
        let global_time_secs = 100000;
        timestamp::update_global_time_for_test_secs(global_time_secs);

        // Initialize the module
        let max_user_entropy_count = 2;
        let max_secs_per_phase = 100;
        init_module(&rng_account, max_user_entropy_count, max_secs_per_phase);

        // Commit some entropy for user 1
        let raw_entropy_1 = 1111;
        let hashed_entropy_1 = hash::sha3_256(bcs::to_bytes(&raw_entropy_1));
        let raw_backup_entropy_1 = 12121;
        let hashed_backup_entropy_1 = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy_1));
        commit_entropy(&user_account_1, hashed_entropy_1, hashed_backup_entropy_1);

        // Commit some entropy for user 2
        let raw_entropy_2 = 0;
        let hashed_entropy_2 = hash::sha3_256(bcs::to_bytes(&raw_entropy_2));
        let raw_backup_entropy_2 = 12132;
        let hashed_backup_entropy_2 = hash::sha3_256(bcs::to_bytes(&raw_backup_entropy_2));
        commit_entropy(&user_account_2, hashed_entropy_2, hashed_backup_entropy_2);

        // Elapse enough time so that we now move to the reveal phase
        global_time_secs = global_time_secs + max_secs_per_phase + 1;
        timestamp::update_global_time_for_test_secs(global_time_secs);

        // Reveal the entropy for user 1
        reveal_entropy(&user_account_1, raw_entropy_1);

        // Elapse enough time so that we now move to the backup reveal phase
        global_time_secs = global_time_secs + max_secs_per_phase + 1;
        timestamp::update_global_time_for_test_secs(global_time_secs);

        // Attempting to reveal the entropy for user 2 should fail
        reveal_entropy(&user_account_1, raw_entropy_2);
    }
}
